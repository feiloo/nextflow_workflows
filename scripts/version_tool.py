# begin generated by Qwen3-235B-A22B-GGUF
import re
import argparse
import sys

SEMVER_REGEX = r'^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-])(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$'

def read_version(filename):
    try:
        with open(filename, "r") as f:
            content = f.read().strip()
    except FileNotFoundError:
        print(f"Error: File not found: {filename}")
        sys.exit(1)
    except Exception as e:
        print(f"Error reading file {filename}: {e}")
        sys.exit(1)

    match_ = re.fullmatch(SEMVER_REGEX, content)
    if not match_:
        print(f"Invalid semantic version in file {filename}: '{content}'")
        print("Expected format: MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]")
        print("Example: 1.2.3, 2.0.0-beta.1+sha1-abcd1234")
        sys.exit(1)

    parts = list(map(int, [match_['major'],match_['minor'],match_['patch']])) + [match_['prerelease'], match_['buildmetadata']]
    return tuple(parts), content

def write_version(version, filename):
    try:
        with open(filename, "w") as f:
            f.write(".".join(map(str, version)))
    except Exception as e:
        print(f"Error writing to file {filename}: {e}")
        sys.exit(1)

def bump_version(current, part):
    major, minor, patch = current[:3]
    if part == "major":
        return (major + 1, 0, 0)
    elif part == "minor":
        return (major, minor + 1, 0)
    elif part == "patch":
        return (major, minor, patch + 1)
    else:
        raise ValueError(f"Invalid part: {part}. Choose 'major', 'minor', or 'patch'.")

def version_follows(new, old):
    return new in [bump_version(old, p) for p in ['major','minor','patch']]

def main():
    parser = argparse.ArgumentParser(description="Bump or check if a semantic versions follows another.")
    subparsers = parser.add_subparsers(dest="command", required=True)

    # Bump command
    bump_parser = subparsers.add_parser("bump", help="Bump version in a file. Drops prerelease and buildmetadata suffices.")
    bump_parser.add_argument("part", choices=["major", "minor", "patch"], help="Which part to bump.")
    bump_parser.add_argument("file", help="File containing the version to bump.")

    # Compare command
    follows_parser = subparsers.add_parser("follows", help="Check that a version file follows another.")
    follows_parser.add_argument("file1", help="First version file (expected to be older).")
    follows_parser.add_argument("file2", help="Second version file (expected to be newer).")

    args = parser.parse_args()

    if args.command == "bump":
        old_version, old_version_string = read_version(args.file)
        new_version = bump_version(old_version, args.part)
        write_version(new_version, args.file)
        print(f"Bumped version in {args.file}:")
        print(f"   Old: {old_version_string}")
        print(f"   New: {'.'.join(map(str, new_version))}")

    elif args.command == "follows":
        v1 = read_version(args.file1)
        v2 = read_version(args.file2)
        if version_follows(v2, v1):
            print(f"Success: Version in {args.file2} follows {args.file1}")
            print(f"   {v2} > {v1}")
            sys.exit(0)
        else:
            print(f"Error: Version in {args.file2} is NOT greater than in {args.file1}")
            print(f"   {args.file1}: {v1}")
            print(f"   {args.file2}: {v2}")
            sys.exit(1)

if __name__ == "__main__":
    main()

# end generated by Qwen3-235B-A22B-GGUF
